# -*- coding: utf-8 -*-
"""
Created on Mon Nov  9 18:59:47 2020

@author: sherr
"""
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties
from matplotlib.ticker import FuncFormatter
import random
import seaborn as sns
import pyecharts
from pyecharts import options as opts
from pyecharts.charts import Bar,Page,Line,Timeline,Scatter
import os
import gc
from pipetools import pipe
import re
import pickle
from sklearn.metrics import roc_auc_score,auc
from sklearn.model_selection import train_test_split,GridSearchCV
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.naive_bayes import GaussianNB
pd.set_option('display.max_columns',None)
pd.set_option('display.max_rows',None)
import pandas as pd
from sklearn.ensemble import RandomForestClassifier, forest, GradientBoostingClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score,roc_curve
import matplotlib.pyplot as plt
from IPython.display import display
import numpy as np
import scipy
import re
import lightgbm as lgb
#import xgboost as xgb
from scipy.sparse import vstack, csr_matrix, save_npz, load_npz
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.model_selection import StratifiedKFold

dtypes_1 = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float32',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int16',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float64', # was 'float32'
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float32', # was 'float16'
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float32', # was 'float16'
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float64', # was 'float32'
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float64', # was 'float32'
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32', # was 'float16'
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32', # was 'float16'
        'Census_InternalPrimaryDisplayResolutionVertical':      'float32', # was 'float16'
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float64', # was 'float32'
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        #'HasDetections':                                        'int8'
        'HasDetections':                                        'float16'
        }
# Loading Training Data
n=8921483 # Data size
s=892148 # Sample Size
skip_1=sorted(random.sample(range(n),n-s+1))
print('Begin Loading...')
df_train=pd.read_csv('train.csv',skiprows=skip_1,header=None,names=dtypes_1.keys(),dtype=dtypes_1)
# Loading Testing Data
#n=624503.81 #Data Size
#s=392662 #Sample Size
#skip_2=sorted(random.sample(range(n),n-s+1))
#df_test=pd.read_csv('test.csv',skiprows=skip_2,header=None,names=dtypes_2.keys(),dtype=dtypes_2)
# Saving samples
df_train.to_csv(r'C:\Users\sherr\Sherry\Carlson\Courses\6110 Business Essentials\Final Project\microsoft_train_data_2.csv',index=False)
#df_test.to_csv(r'C:\Users\sherr\Sherry\Carlson\Courses\6110 Business Essentials\Final Project\microsoft_test_data_2.csv',index=False)
def rename_edition(x):
    x = x.lower()
    if 'core' in x:
        return 'Core'
    elif 'pro' in x:
        return 'pro'
    elif 'enterprise' in x:
        return 'Enterprise'
    elif 'server' in x:
        return 'Server'
    elif 'home' in x:
        return 'Home'
    elif 'education' in x:
        return 'Education'
    elif 'cloud' in x:
        return 'Cloud'
    else:
        return x
#%% Feature Engineering
def fe(train):
    print('Begin Feature Engineering...')
    df=train.copy()
    #Splitting everything out
    df['OsBuildLab'] = df['OsBuildLab'].cat.add_categories(['0.0.0.0.0-0'])
    df['OsBuildLab'] = df['OsBuildLab'].fillna('0.0.0.0.0-0')
    
    df['EngineVersion_2'] = df['EngineVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    df['EngineVersion_3'] = df['EngineVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    df['AppVersion_1'] = df['AppVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    df['AppVersion_2'] = df['AppVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    df['AppVersion_3'] = df['AppVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    df['AvSigVersion_0'] = df['AvSigVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    df['AvSigVersion_1'] = df['AvSigVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    df['AvSigVersion_2'] = df['AvSigVersion'].apply(lambda x: x.split('.')[2]).astype('category')

    df['OsBuildLab_0'] = df['OsBuildLab'].apply(lambda x: x.split('.')[0]).astype('category')
    df['OsBuildLab_1'] = df['OsBuildLab'].apply(lambda x: x.split('.')[1]).astype('category')
    df['OsBuildLab_2'] = df['OsBuildLab'].apply(lambda x: x.split('.')[2]).astype('category')
    df['OsBuildLab_3'] = df['OsBuildLab'].apply(lambda x: x.split('.')[3]).astype('category')

    df['Census_OSVersion_0'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    df['Census_OSVersion_1'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    df['Census_OSVersion_2'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    df['Census_OSVersion_3'] = df['Census_OSVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    
    # https://www.kaggle.com/adityaecdrid/simple-feature-engineering-xd
    df['primary_drive_c_ratio'] = df['Census_SystemVolumeTotalCapacity']/ df['Census_PrimaryDiskTotalCapacity']
    #df['non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']
    
    df['aspect_ratio'] = df['Census_InternalPrimaryDisplayResolutionHorizontal']/ df['Census_InternalPrimaryDisplayResolutionVertical']
    #df['monitor_dims'] = df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(str) + '*' + df['Census_InternalPrimaryDisplayResolutionVertical'].astype('str')
    #df['monitor_dims'] = df['monitor_dims'].astype('category')

    df['dpi'] = ((df['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + df['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5)/(df['Census_InternalPrimaryDiagonalDisplaySizeInInches'])

    #df['dpi_square'] = df['dpi'] ** 2

    df['MegaPixels'] = (df['Census_InternalPrimaryDisplayResolutionHorizontal'] * df['Census_InternalPrimaryDisplayResolutionVertical'])/1e6

    #df['Screen_Area'] = (df['aspect_ratio']* (df['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2))/(df['aspect_ratio']**2 + 1)

    df['ram_per_processor'] = df['Census_TotalPhysicalRAM']/ df['Census_ProcessorCoreCount']

    df['new_num_0'] = df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] / df['Census_ProcessorCoreCount']
    
    df['new_num_1'] = df['Census_ProcessorCoreCount'] * df['Census_InternalPrimaryDiagonalDisplaySizeInInches']
    
    df['Census_IsFlightingInternal'] = df['Census_IsFlightingInternal'].fillna(1)
    df['Census_ThresholdOptIn'] = df['Census_ThresholdOptIn'].fillna(1)
    df['Census_IsWIMBootEnabled'] = df['Census_IsWIMBootEnabled'].fillna(1)
    df['Wdft_IsGamer'] = df['Wdft_IsGamer'].fillna(0) 
    
    # 
    df.loc[df['AVProductsInstalled'].isin([1, 2]) == False, 'AVProductsInstalled'] = 3
    df.loc[df['OrganizationIdentifier'].isin([27, 18]) == False, 'OrganizationIdentifier'] = 48
    df['OrganizationIdentifier'] = df['OrganizationIdentifier'].astype('category')
    
    df['Census_OSSkuName'] = df['Census_OSSkuName'].astype(str)
    df['Census_OSSkuName'] = df['Census_OSSkuName'].apply(rename_edition)
    df['Census_OSSkuName'] = df['Census_OSSkuName'].astype('category')


    df.loc[df['Census_ProcessorCoreCount'].isin([2, 4, 8, 12]) == False, 'Census_ProcessorCoreCount'] = 1

    top_10 = df['Census_TotalPhysicalRAM'].value_counts(dropna=False, normalize=True).cumsum().index[:10]
    df.loc[df['Census_TotalPhysicalRAM'].isin(top_10) == False, 'Census_TotalPhysicalRAM'] = 1000

    def group_battery(x):
        x = x.lower()
        if 'li' in x:
            return 1
        else:
            return 0
    
    df['Census_InternalBatteryType'] = df['Census_InternalBatteryType'].apply(group_battery)
    
    
    df.loc[df['SmartScreen'].isnull(), 'SmartScreen'] = 'ExistsNotSet'
    df.loc[df['SmartScreen'].isin(['RequireAdmin', 'ExistsNotSet', 'Off', 'Warn']) == False, 'SmartScreen'] = 'Prompt'
    df['SmartScreen'] = df['SmartScreen'].cat.remove_unused_categories()

    df.loc[df['Census_PrimaryDiskTypeName'].isin(['HDD', 'SSD']) == False, 'Census_PrimaryDiskTypeName'] = 'UNKNOWN'
    df['Census_PrimaryDiskTypeName'] = df['Census_PrimaryDiskTypeName'].cat.remove_unused_categories()

    df.loc[df['Census_ProcessorManufacturerIdentifier'].isin([5.0, 1.0]) == False, 'Census_ProcessorManufacturerIdentifier'] = 0.0
    df['Census_ProcessorManufacturerIdentifier'] = df['Census_ProcessorManufacturerIdentifier'].astype('category')
    
    df.loc[df['Census_PowerPlatformRoleName'].isin(['Mobile', 'Desktop', 'Slate']) == False, 'Census_PowerPlatformRoleName'] = 'UNKNOWN'
    df['Census_PowerPlatformRoleName'] = df['Census_PowerPlatformRoleName'].cat.remove_unused_categories()
    
    
    top_cats = list(df['Census_OSWUAutoUpdateOptionsName'].value_counts().index[:3])
    df.loc[df['Census_OSWUAutoUpdateOptionsName'].isin(top_cats) == False, 'Census_OSWUAutoUpdateOptionsName'] = 'Off'
    df['Census_OSWUAutoUpdateOptionsName'] = df['Census_OSWUAutoUpdateOptionsName'].cat.remove_unused_categories()
    
    df.loc[df['Census_GenuineStateName'] == 'UNKNOWN', 'Census_GenuineStateName'] = 'OFFLINE'
    df['Census_GenuineStateName'] = df['Census_GenuineStateName'].cat.remove_unused_categories()
    
    
    df.loc[df['Census_ActivationChannel'].isin(['Retail', 'OEM:DM']) == False, 'Census_ActivationChannel'] = 'Volume:GVLK'
    df['Census_ActivationChannel'] = df['Census_ActivationChannel'].cat.remove_unused_categories()
    
    
    # Drop for memory
    

    df.drop('Census_InternalPrimaryDisplayResolutionHorizontal', axis=1)
    df.drop('Census_OSUILocaleIdentifier', axis=1)
    df.drop('AppVersion_3',axis=1)
    
    remove_cols = ['PuaMode', 'Census_ProcessorClass', 
                   'Census_IsWIMBootEnabled', 'IsBeta', 
                   'Census_IsFlightsDisabled', 'Census_IsFlightingInternal', 
                   'AutoSampleOptIn', 'Census_ThresholdOptIn', 'SMode', 
                   'Census_IsPortableOperatingSystem', 'Census_DeviceFamily', 
                   'UacLuaenable', 'Census_IsVirtualDevice', 'Platform', 
                   'Census_OSSkuName', 'Census_OSInstallLanguageIdentifier', 'Processor']
    df.drop(remove_cols, axis=1, inplace=True)
    
    gc.collect()
    print('Finish Feature Engineering','Total Column:',df.shape[1])    
    return df
#%%
def Combiner(df, col, val_lower, otherval):
    top_cat = list(df[col].value_counts(dropna=False).index[:])
    df_split=df.loc[df[col].isin(top_cat)]
    
    a = df_split[col].value_counts()
    m = df_split[col].isin(a.index[a<val_lower])
    m = list(m)
    df.loc[m, col] = otherval
        
    return df
#%%
def dateFE(df, col,datedict):
    print('Begin add time stamp...')
    #Date information
    label='Date'+str(col)
    df['Date'+str(col)] = df[col].map(datedict)
    add_datepart(df, 'Date'+str(col), drop=False)
    datetime =  df['Date'+str(col)].max()
    print(datetime)
    df['DaysElapsed'+col]=  ((datetime)- df['Date'+str(col)]).dt.days
    df=df.drop(label,axis =1)
    print('Variable is '+str(label))
    print(f'Final Columns: {df.shape[1]}, Finish adding time stamp')
    return df
#%%
def add_datepart(df, fldname, drop=True, time=False):
    "Helper function that adds columns relevant to a date."
    fld = df[fldname]
    fld_dtype = fld.dtype
    if isinstance(fld_dtype, pd.core.dtypes.dtypes.DatetimeTZDtype):
        fld_dtype = np.datetime64

    if not np.issubdtype(fld_dtype, np.datetime64):
        df[fldname] = fld = pd.to_datetime(fld, infer_datetime_format=True)
    targ_pre = re.sub('[Dd]ate$', '', fldname)
    attr = ['Year', 'Month', 'Week', 'Day', 'Dayofweek']
    #, 'Dayofyear', 'Is_month_end'], 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start', 'Is_year_end', 'Is_year_start']
    if time: attr = attr + ['Hour', 'Minute', 'Second']
    for n in attr: df[targ_pre + n] = getattr(fld.dt, n.lower())
    #df[targ_pre + 'Elapsed'] = fld.astype(np.int64) // 10 ** 9
    if drop: df.drop(fldname, axis=1, inplace=True)
#%%
#Decrease number of unique values
def DecreaseUniqueValues(train):
    print("Decreasing Unique Values for 'AvSigVersion','AVProductStatesIdentifier','CityIdentifier','Census_OEMNameIdentifier','Census_InternalBatteryNumberOfCharges','Census_FirmwareVersionIdentifier'")
    print("Original Unique Values:",
        train['AvSigVersion'].nunique(),train['AVProductStatesIdentifier'].nunique(), train['CityIdentifier'].nunique(),train['Census_OEMNameIdentifier'].nunique(),train['Census_InternalBatteryNumberOfCharges'].nunique(),train['Census_FirmwareVersionIdentifier'].nunique()
    )
    cutoff=50
    #Combiner(train,'AvSigVersion',cutoff,'0.0.0.0')
    Combiner(train,'AVProductStatesIdentifier',cutoff, '0.0')
    Combiner(train,'CityIdentifier',cutoff,'0.0')
    Combiner(train,'Census_OEMNameIdentifier',cutoff,'3')
    Combiner(train,'Census_InternalBatteryNumberOfCharges',cutoff,'50')
    Combiner(train,'Census_FirmwareVersionIdentifier',cutoff,'50')
    print("Final Unique Values:",
          train['AvSigVersion'].nunique(),train['AVProductStatesIdentifier'].nunique(), train['CityIdentifier'].nunique(),train['Census_OEMNameIdentifier'].nunique(),train['Census_InternalBatteryNumberOfCharges'].nunique(),train['Census_FirmwareVersionIdentifier'].nunique()
         )
    return train
#%%
#Remove columns that have one category that take up more than 95% of the data
def RemoveMonopolyCol(train):
    print('Removing Columns with Monopoly Categories...')
    removeCols=[]
    for col in train.columns:
        rate = train[col].value_counts(normalize=True, dropna=False).values[0]
        if rate > 0.95:
            removeCols.append(col)
    train.drop(removeCols,axis=1,inplace=True)
    print(f'Dropped {len(removeCols)} columns','Total Column:',train.shape[1])
    return train
#%%
def DataPipeline(df,with_engineering=True):
    for i in df.columns:
        if df[i].dtype=='O' and not np.issubdtype(df[i].dtype, np.number):
            df[i]=df[i].astype('category')
    print('Original Columns:',df.shape[1])
    datedictAS = np.load('AvSigVersionTimestamps.npy',allow_pickle=True)[()]
    datedictOS = np.load('OSVersionTimestamps.npy',allow_pickle=True)[()]
    print('Begin Pipe...')
    if with_engineering:
        df=fe(df).pipe(DecreaseUniqueValues)\
                   .pipe(RemoveMonopolyCol)\
                   .pipe(dateFE,'AvSigVersion',datedictAS)\
                   .pipe(dateFE,'Census_OSVersion',datedictOS)
    else:
        df=df.pipe(DecreaseUniqueValues)\
           .pipe(RemoveMonopolyCol)\
           .pipe(dateFE,'AvSigVersion',datedictAS)\
           .pipe(dateFE,'Census_OSVersion',datedictOS)
    df.fillna(method='bfill',inplace=True)
    df.fillna(method='ffill',inplace=True)
    print('Discretize data for certain column...')
    if with_engineering:
        bin_1=np.arange(df['primary_drive_c_ratio'].min(),df['primary_drive_c_ratio'].max(),500)
        df['primary_drive_c_ratio']=np.digitize(df['primary_drive_c_ratio'],bins=bin_1)
        bin_4=np.arange(df['aspect_ratio'].min(),df['aspect_ratio'].max(),20)
        df['aspect_ratio']=np.digitize(df['aspect_ratio'],bins=bin_4)
        bin_5=np.arange(df['dpi'].min(),df['dpi'].max(),100)
        df['dpi']=np.digitize(df['dpi'],bins=bin_5)
        bin_6=np.arange(df['MegaPixels'].min(),df['MegaPixels'].max(),20)
        df['MegaPixels']=np.digitize(df['MegaPixels'],bins=bin_6)
    
    
    bin_2=np.arange(df['Census_SystemVolumeTotalCapacity'].min(),df['Census_SystemVolumeTotalCapacity'].max(),500)
    df['Census_SystemVolumeTotalCapacity']=np.digitize(df['Census_SystemVolumeTotalCapacity'],bins=bin_2)
    
    bin_3=np.arange(df['Census_OEMModelIdentifier'].min(),df['Census_OEMModelIdentifier'].max(),300)
    df['Census_OEMModelIdentifier']=np.digitize(df['Census_OEMModelIdentifier'],bins=bin_3)   
    

    
    for usecol in df.columns.tolist():
        df[usecol] = df[usecol].astype('str')
        #Fit LabelEncoder
        le = LabelEncoder().fit(np.unique(df[usecol].unique().tolist()))
        #At the end 0 will be used for dropped values
        df[usecol] = le.transform(df[usecol])+1
    print(f'Cleaned data has {df.shape[0]} rows,{df.shape[1]} columns')
    return df
#%%
def TrainTest(df,with_engineering=True):
    train=DataPipeline(df,with_engineering=with_engineering)
    X_train,X_test,Y_train,Y_test=train_test_split(train.drop(['HasDetections','MachineIdentifier'],axis=1),
                                                   train['HasDetections'], test_size=0.4,random_state=42)
    Y_train = np.array(Y_train)
    Y_test = np.array(Y_test)
    train_ids = X_train.index
    test_ids  = X_test.index
    print('Y_train',Y_train.shape)
    print('Y_test',Y_test.shape)
    return X_train,X_test,Y_train,Y_test,train_ids,test_ids
#%% Load saved sample data
train_path=r'C:\Users\sherr\Sherry\Carlson\Courses\6110 Business Essentials\Final Project\microsoft_train_data_2.csv'
#test_path=r'C:\Users\sherr\Sherry\Carlson\Courses\6110 Business Essentials\Final Project\microsoft_test_data_2.csv'
df_raw=pd.read_csv(train_path)
df=df_raw.copy()
X_train_1,X_test_1,Y_train_1,Y_test_1,train_ids_1,test_ids_1=TrainTest(df,with_engineering=False)
X_train,X_test,Y_train,Y_test,train_ids,test_ids=X_train_1,X_test_1,Y_train_1,Y_test_1,train_ids_1,test_ids_1
print(X_train.shape)
#%%
#Drop test dataset categories that does not exist in train data set
X_test['Y']=Y_test
count=0
for i in X_train.columns:
    print(f'start the {count} column {i}')
    count+=1
    train_cat=X_train[i].value_counts().index
    test_cat=X_test[i].value_counts().index   
    diff=np.setdiff1d(test_cat, train_cat)
    print(len(diff))
    for j in diff:
        print('begin drop',j)
        X_test.drop(X_test[X_test[i]==j].index,axis=0,inplace=True)
Y_test=X_test['Y']
test_ids=Y_test.index
X_test.drop('Y',axis=1,inplace=True)
print(f'X_train: {X_train.shape},X_test:{X_test.shape},Y_train:{Y_train.shape},X_test:{Y_test.shape}')
#Fit OneHotEncoder
ohe = OneHotEncoder(categories='auto', sparse=True, dtype='uint8').fit(X_train)
#%%
#Transform data using small groups to reduce memory usage
m = 100000
train = vstack([ohe.transform(X_train[i*m:(i+1)*m]) for i in range(X_train.shape[0] // m + 1)])
test = vstack([ohe.transform(X_test[i*m:(i+1)*m]) for i in range(X_test.shape[0] // m + 1)])
save_npz('train.npz', train, compressed=True)
save_npz('test.npz',  test,  compressed=True)
del ohe, train, test
gc.collect()    
#%%
def ROC(y_true,pred_list,pos_label,color,label):    
    plt.figure(figsize=[10,10])
    for i,j,k in zip(pred_list,color,label):
        fpr, tpr, thresholds = roc_curve(y_true,i, pos_label=pos_label)
        auc_score = auc(fpr, tpr)
        print(f'auc for {k} is {auc_score}')
        plt.plot(fpr,tpr,label=k,color=j)
    plt.xlabel('FPR',fontsize=30)
    plt.ylabel('TPR',fontsize=30)
    plt.legend()
    plt.show()    
#%%
def print_score(m):
    res = [roc_auc_score(m.predict(X_train), Y_train), roc_auc_score(m.predict(X_test), Y_test), 
           m.score(X_train, Y_train), m.score(X_test, Y_test)
          ]
    if hasattr(m,'oob_score_'): res.append(m.oob_score_)
    print("train_auc,test_auc,train_accuracy,test_accuracy\n",res)
#%% LightGBM
skf = StratifiedKFold(n_splits=2, shuffle=True, random_state=42)
skf.get_n_splits(train_ids, Y_train)

lgb_test_result  = np.zeros(test_ids.shape[0])
#lgb_train_result = np.zeros(train_ids.shape[0])
#xgb_test_result  = np.zeros(test_ids.shape[0])
#xgb_train_result = np.zeros(train_ids.shape[0])
counter = 0

print('\nLightGBM\n')

for train_index, test_index in skf.split(train_ids, Y_train):
    
    print('Fold {}\n'.format(counter + 1))
    
    train = load_npz('train.npz')
    X_fit = vstack([train[train_index[i*m:(i+1)*m]] for i in range(train_index.shape[0] // m + 1)])
    X_val = vstack([train[test_index[i*m:(i+1)*m]]  for i in range(test_index.shape[0] //  m + 1)])
    X_fit, X_val = csr_matrix(X_fit, dtype='float32'), csr_matrix(X_val, dtype='float32')
    y_fit, y_val = Y_train[train_index], Y_train[test_index]
    
    del train
    gc.collect()

    lgb_model = lgb.LGBMClassifier(max_depth=-1,
                                   n_estimators=30000,
                                   learning_rate=0.015,
                                   num_leaves=2**11-200,
                                   colsample_bytree=0.28,
                                   random_state=23,
                                   min_child_samples=20,
                                   objective='binary', 
                                   subsample=0.5,
                                   n_jobs=-1)
                                   
    #xgb_model = xgb.XGBClassifier(max_depth=6,
     #                             n_estimators=30000,
      #                            colsample_bytree=0.2,
      #                            learning_rate=0.1,
       #                           objective='binary:logistic', 
        #                          n_jobs=-1)
    
                               
    lgb_model.fit(X_fit, y_fit, eval_metric='auc', 
                  eval_set=[(X_val, y_val)], 
                  verbose=100, early_stopping_rounds=100)
    del X_fit, X_val, y_fit, y_val, train_index, test_index
    gc.collect()
    
    test = load_npz('test.npz')
    test = csr_matrix(test, dtype='float32')
    lgb_test_result += lgb_model.predict_proba(test)[:,1]
    #xgb_test_result += xgb_model.predict_proba(test)[:,1]
    counter += 1
    
    del test
    gc.collect()
#%% Predict
lgb_pred=lgb_test_result/3
ROC(Y_test,[lgb_pred],2,'red',['LGB'])    
#%% Random Forest
m = RandomForestClassifier(n_estimators=40, min_samples_leaf=60, max_features=0.5, n_jobs=-1, oob_score=False)
%time m.fit(X_train, Y_train)
print_score(m)
#%% Predict
pred_proba=m.predict_proba(X_test)
forest_pred=[]
for i in pred_proba:
    forest_pred.append(i[1])
result=pd.DataFrame({'ActualResult':list(Y_test),'PredictProbility':forest_pred}).sort_values('PredictProbility',ascending=False)
result.sample(10)
#%% Naive Bayes Model
gnb = GaussianNB()
nb_model=gnb.fit(X_train, Y_train)
pred_proba =nb_model.predict_proba(X_test)
#%% Predict
nb_pred=[]
for i in pred_proba:
    nb_pred.append(i[1])
result=pd.DataFrame({'ActualResult':list(Y_test),'PredictProbility':nb_pred}).sort_values('PredictProbility',ascending=False)
result.sample(10)
#%%
#Save the 3 prediction result 
lgb_pred_2,forest_pred_2,nb_pred_2=lgb_pred.copy(),forest_pred.copy(),nb_pred.copy()
eng_predict=pd.DataFrame({'Actual':Y_test,'LGB':lgb_pred_2,'Random_Forest':forest_pred_2,'Naive Bayes':nb_pred_2})
eng_predict.to_csv('eng_predict.csv')
#%% Define function that returns metrics
def Metrics(fig,ax,color,df,i):
    df=df[['Actual',i]]
    df=df.sort_values(i,ascending=False).reset_index()[['Actual',i]]
    df['Percision_pos']=np.cumsum(df['Actual'])/(np.array(df.index)+1)
    df['Recall_pos']=np.cumsum(df['Actual'])/sum(df['Actual'])
    df['Combined_Score']=df['Percision_pos']*df['Recall_pos']*2/(df['Recall_pos']*0.9+df['Percision_pos'])
    max_value=df[df['Combined_Score']==df['Combined_Score'].max()][i].values
    print('The cutoff is:',max_value)
    print(df[df['Combined_Score']==df['Combined_Score'].max()])
    predict=[]
    for j in range(len(df)):
        if df.loc[j,i]>max_value:
            predict.append(1),
        elif df.loc[j,i]<=max_value:
            predict.append(0)
    df['predict']=predict
    final=df[['Actual','predict']]
    total=final.shape[0]
    act_T=final['Actual'].sum()
    accu=final[final['Actual']==final['predict']]
    TP=final[(final['Actual']==final['predict'])&(final['Actual']==1)]
    Total_P=final[final['predict']==1]
    print('Accuracy:',round(len(accu)/total,3))
    print('Percision:',round(len(TP)/len(Total_P),3))
    print('Recall:',round(len(TP)/act_T,3))
    ax.plot(df['Combined_Score'],label=i,color=color,linewidth=2)
#%% Visualize Result
fig,ax=plt.subplots(figsize=[12,8])
Metrics(fig,ax,'steelblue',df,'LGB')
Metrics(fig,ax,'gray',df,'Random_Forest')
Metrics(fig,ax,'black',df,'Naive Bayes')
plt.legend(fontsize=20,frameon=False)
plt.xticks([1],[""])
plt.yticks([1],[""])
ax.spines['top'].set_linewidth(0)
ax.spines['right'].set_linewidth(0)
plt.savefig('modelresult.png',transparent=True,bbox_inches='tight')



























